--- a/sound/isa/cs423x/cs4236_lib.c
+++ b/sound/isa/cs423x/cs4236_lib.c
@@ -1,10 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
- *  Routines for control of CS4235/4236B/4237B/4238B/4239 chips
+ *
+ *  Edited by linic@hotmail.ca.
+ *  Routines for control of CS4237B for the ThinkPad 560Z
  *
  *  Note:
- *     -----
+ *  - Removed control port since my 560z doesn't expose the control device.
+ *  - Removed many hardware checks since my 560z is successfully detected as a WSS_HW_CS4237B.
+ *  - After the module has loaded, run "sudo alsactl init CS4237B" and then "alsamixer" to up the volumes.
+ *    "sudo alsactl store CS4237B" can be used to save the alsa settings including the volumes.
+ *    After a reboot, "sudo alsactl init CS4237B" and "sudo alsactl restore CS4237B" are needed for
+ *    sound to be audible.
+ *    I kept the control registers documentation in below, but it doesn't apply to the 560z.
  *
  *  Bugs:
  *     -----
@@ -101,21 +109,34 @@
 	/* CS4236_RIGHT_WAVE */		0xbf
 };
 
-/*
- *
- */
-
-static void snd_cs4236_ctrl_out(struct snd_wss *chip,
-				unsigned char reg, unsigned char val)
-{
-	outb(reg, chip->cport + 3);
-	outb(chip->cimage[reg] = val, chip->cport + 4);
-}
-
-static unsigned char snd_cs4236_ctrl_in(struct snd_wss *chip, unsigned char reg)
-{
-	outb(reg, chip->cport + 3);
-	return inb(chip->cport + 4);
+/* Read the indirect registers one by one. */
+static void decode_version(struct snd_card *card, unsigned char value) {
+	unsigned char chip_id_mask = 0b00011111;//01000  CS4237B
+	unsigned char cs4237b_chip_id = 0b00001000;
+	unsigned char read_chip_id = 0;
+	unsigned char read_version = 0;
+	unsigned char version_mask = 0b11100000;
+	unsigned char revision_a = 0b10000000;
+	unsigned char revision_b = 0b10100000;
+	unsigned char revision_cd = 0b11000000;
+	unsigned char revision_e = 0b11100000;
+	dev_dbg(card->dev, "Version=0x%x\n", read_version);
+	read_chip_id = value & chip_id_mask;
+	read_version = value & version_mask;
+	if (read_chip_id == cs4237b_chip_id)
+		dev_dbg(card->dev, "Chip id matches CS4237B\n");
+	else
+		dev_dbg(card->dev, "Chip id unknonwn\n");
+	if (read_version == revision_a)
+		dev_dbg(card->dev, "Version matches revision a\n");
+	else if (read_version == revision_b)
+		dev_dbg(card->dev, "Version matches revision b\n");
+	else if (read_version == revision_cd)
+		dev_dbg(card->dev, "Version matches revision c/d\n");
+	else if (read_version == revision_e)
+		dev_dbg(card->dev, "Version matches revision e\n");
+	else
+		dev_dbg(card->dev, "Version has unknown revision\n");
 }
 
 /*
@@ -208,8 +229,6 @@
 		chip->image[reg] = snd_wss_in(chip, reg);
 	for (reg = 0; reg < 18; reg++)
 		chip->eimage[reg] = snd_cs4236_ext_in(chip, CS4236_I23VAL(reg));
-	for (reg = 2; reg < 9; reg++)
-		chip->cimage[reg] = snd_cs4236_ctrl_in(chip, reg);
 }
 
 static void snd_cs4236_resume(struct snd_wss *chip)
@@ -232,14 +251,6 @@
 		}
 		for (reg = 0; reg < 18; reg++)
 			snd_cs4236_ext_out(chip, CS4236_I23VAL(reg), chip->eimage[reg]);
-		for (reg = 2; reg < 9; reg++) {
-			switch (reg) {
-			case 7:
-				break;
-			default:
-				snd_cs4236_ctrl_out(chip, reg, chip->cimage[reg]);
-			}
-		}
 	}
 	snd_wss_mce_down(chip);
 }
@@ -248,25 +259,27 @@
 /*
  * This function does no fail if the chip is not CS4236B or compatible.
  * It just an equivalent to the snd_wss_create() then.
+ * linic@hotmail.ca: Modified the snd_cs4236_create to work without control port/device
  */
 int snd_cs4236_create(struct snd_card *card,
 		      unsigned long port,
-		      unsigned long cport,
 		      int irq, int dma1, int dma2,
 		      unsigned short hardware,
 		      unsigned short hwshare,
 		      struct snd_wss **rchip)
 {
 	struct snd_wss *chip;
-	unsigned char ver1, ver2;
+	unsigned char version;
 	unsigned int reg;
 	int err;
 
 	*rchip = NULL;
 	if (hardware == WSS_HW_DETECT)
 		hardware = WSS_HW_DETECT3;
-
-	err = snd_wss_create(card, port, cport,
+	/* I removed the control port. I probably could have set it to -1 instead, but
+	 * I didn't test setting it to -1 only and using "alsactl init CS4237B" and
+	 * alsamixer to set the volumes to 100.  */
+	err = snd_wss_create(card, port,
 			     irq, dma1, dma2, hardware, hwshare, &chip);
 	if (err < 0)
 		return err;
@@ -277,47 +290,35 @@
 		*rchip = chip;
 		return 0;
 	}
-#if 0
-	{
-		int idx;
-		for (idx = 0; idx < 8; idx++)
-			dev_dbg(card->dev, "CD%i = 0x%x\n",
-				idx, inb(chip->cport + idx));
-		for (idx = 0; idx < 9; idx++)
-			dev_dbg(card->dev, "C%i = 0x%x\n",
-				idx, snd_cs4236_ctrl_in(chip, idx));
-	}
-#endif
-	if (cport < 0x100 || cport == SNDRV_AUTO_PORT) {
-		dev_err(card->dev, "please, specify control port for CS4236+ chips\n");
-		return -ENODEV;
-	}
-	ver1 = snd_cs4236_ctrl_in(chip, 1);
-	ver2 = snd_cs4236_ext_in(chip, CS4236_VERSION);
-	dev_dbg(card->dev, "CS4236: [0x%lx] C1 (version) = 0x%x, ext = 0x%x\n",
-		cport, ver1, ver2);
-	if (ver1 != ver2) {
-		dev_err(card->dev,
-			"CS4236+ chip detected, but control port 0x%lx is not valid\n",
-			cport);
-		return -ENODEV;
-	}
-	snd_cs4236_ctrl_out(chip, 0, 0x00);
-	snd_cs4236_ctrl_out(chip, 2, 0xff);
-	snd_cs4236_ctrl_out(chip, 3, 0x00);
-	snd_cs4236_ctrl_out(chip, 4, 0x80);
+
+	/* According to the CS4237B documentation:
+	 * Version / Chip ID (C1)
+	 * Default = 11001000
+	 * D7 D6 D5 D4 D3 D2 D1 D0
+	 * V2 V1 V0 CID4 CID3 CID2 CID1 CID0
+	 * CID4-CID0
+	 * Chip Identification. Distinguishes
+	 * between this chip and other codec
+	 * chips that support this register set.
+	 * This register is identical to the WSS
+	 * X25 register.
+	 * 01000 - CS4237B
+	 * V2-V0
+	 * Version number. As enhancements
+	 * are made, the version number is
+	 * changed so software can distinguish
+	 * between the different versions of the
+	 * same chip.
+	 * 100 - Revision A
+	 * 101 - Revision B
+	 * 110 - Revision C/D
+	 * 111 - Revision E
+	 * */
+	version = snd_cs4236_ext_in(chip, CS4236_VERSION);
+	decode_version(card, version);
+
 	reg = ((IEC958_AES1_CON_PCM_CODER & 3) << 6) |
 	      IEC958_AES0_CON_EMPHASIS_NONE;
-	snd_cs4236_ctrl_out(chip, 5, reg);
-	snd_cs4236_ctrl_out(chip, 6, IEC958_AES1_CON_PCM_CODER >> 2);
-	snd_cs4236_ctrl_out(chip, 7, 0x00);
-	/*
-	 * 0x8c for C8 is valid for Turtle Beach Malibu - the IEC-958
-	 * output is working with this setup, other hardware should
-	 * have different signal paths and this value should be
-	 * selectable in the future
-	 */
-	snd_cs4236_ctrl_out(chip, 8, 0x8c);
 	chip->rate_constraint = snd_cs4236_xrate;
 	chip->set_playback_format = snd_cs4236_playback_format;
 	chip->set_capture_format = snd_cs4236_capture_format;
@@ -435,13 +436,13 @@
   .get = snd_cs4236_get_singlec, .put = snd_cs4236_put_singlec, \
   .private_value = reg | (shift << 8) | (mask << 16) | (invert << 24) }
 
+/* I think the c at the end of this method name refers to the control device. Since
+ * there is no control device on the 560z, I believe this is not needed and could be removed. */
 static int snd_cs4236_get_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_wss *chip = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
 	int mask = (kcontrol->private_value >> 16) & 0xff;
 	int invert = (kcontrol->private_value >> 24) & 0xff;
+	/* I removed code which was using cimage since cimage was removed since there's no control device on the 560z */
 	
 	guard(spinlock_irqsave)(&chip->reg_lock);
 	ucontrol->value.integer.value[0] = (chip->cimage[reg] >> shift) & mask;
@@ -450,25 +451,13 @@
 	return 0;
 }
 
+/* I think the c at the end of this method name refers to the control device. Since
+ * there is no control device on the 560z, I believe this is not needed and could be removed. */
 static int snd_cs4236_put_singlec(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_wss *chip = snd_kcontrol_chip(kcontrol);
-	int reg = kcontrol->private_value & 0xff;
-	int shift = (kcontrol->private_value >> 8) & 0xff;
-	int mask = (kcontrol->private_value >> 16) & 0xff;
-	int invert = (kcontrol->private_value >> 24) & 0xff;
-	int change;
-	unsigned short val;
-	
-	val = (ucontrol->value.integer.value[0] & mask);
-	if (invert)
-		val = mask - val;
-	val <<= shift;
-	guard(spinlock_irqsave)(&chip->reg_lock);
-	val = (chip->cimage[reg] & ~(mask << shift)) | val;
-	change = val != chip->cimage[reg];
-	snd_cs4236_ctrl_out(chip, reg, val);
-	return change;
+	/* I removed code which was using cimage since cimage was removed since there's no control device on the 560z */
+	/* Always returning 1 since there's no cimage anymore and no way to know if there was a change or not. */
+	return 1;
 }
 
 #define CS4236_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, shift_right, mask, invert) \
@@ -928,11 +917,7 @@
 		val = (chip->image[CS4231_ALT_FEATURE_1] & ~0x0e) | (0<<2) | (enable << 1);
 		change = val != chip->image[CS4231_ALT_FEATURE_1];
 		snd_wss_out(chip, CS4231_ALT_FEATURE_1, val);
-		val = snd_cs4236_ctrl_in(chip, 4) | 0xc0;
-		snd_cs4236_ctrl_out(chip, 4, val);
 		udelay(100);
-		val &= ~0x40;
-		snd_cs4236_ctrl_out(chip, 4, val);
 	}
 	snd_wss_mce_down(chip);
 
